import React, { useState, useCallback, useMemo } from 'react';
import ReactFlow, {
  Node,
  Edge,
  addEdge,
  useNodesState,
  useEdgesState,
  Connection,
  ReactFlowProvider,
  Controls,
  Background,
  MiniMap,
  Panel,
  ConnectionMode
} from 'reactflow';
import 'reactflow/dist/style.css';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Chip,
  IconButton,
  Drawer,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Divider
} from '@mui/material';
import {
  Add as AddIcon,
  PlayArrow as PlayIcon,
  Save as SaveIcon,
  ExpandMore as ExpandMoreIcon,
  Close as CloseIcon,
  FileOpen as TemplateIcon
} from '@mui/icons-material';
import { CustomNode } from './CustomNode';
import { nodeTemplates, nodeCategories } from '../../constants/nodeTemplates';
import { workflowTemplates } from '../../constants/workflowTemplates';
import { NodeTemplate, WorkflowNode, WorkflowEdge, NodeData } from '../../types/workflow';
import { WorkflowExecutionService } from '../../services/workflowExecutionService';
import { CodeBrowser } from '../code/CodeBrowser';

const nodeTypes = {
  custom: CustomNode,
};

interface WorkflowEditorProps {
  open: boolean;
  onClose: () => void;
  apiClient?: any;
  user?: any;
  onAuthRequired?: () => void;
}

export const WorkflowEditor: React.FC<WorkflowEditorProps> = ({ open, onClose, apiClient, user, onAuthRequired }) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [showNodeSelector, setShowNodeSelector] = useState(false);
  const [showTemplateSelector, setShowTemplateSelector] = useState(false);
  const [selectedNodeForConfig, setSelectedNodeForConfig] = useState<string | null>(null);
  const [nodeConfigs, setNodeConfigs] = useState<Record<string, any>>({});
  const [isExecuting, setIsExecuting] = useState(false);
  const [executingNodes, setExecutingNodes] = useState<Set<string>>(new Set());
  const [showCodeBrowser, setShowCodeBrowser] = useState(false);
  const [generatedCode, setGeneratedCode] = useState<any[]>([]);

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const deleteNode = useCallback((nodeId: string) => {
    setNodes((nds) => nds.filter((node) => node.id !== nodeId));
    setEdges((eds) => eds.filter((edge) => edge.source !== nodeId && edge.target !== nodeId));
    delete nodeConfigs[nodeId];
    setNodeConfigs({ ...nodeConfigs });
  }, [setNodes, setEdges, nodeConfigs]);

  const configureNode = useCallback((nodeId: string) => {
    setSelectedNodeForConfig(nodeId);
  }, []);

  const executeNode = useCallback(async (nodeId: string) => {
    setExecutingNodes(prev => new Set(Array.from(prev).concat(nodeId)));
    
    // Update node to show executing state
    setNodes((nds) =>
      nds.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, isExecuting: true } }
          : node
      )
    );

    // Find the current node
    const currentNode = nodes.find(node => node.id === nodeId);
    
    // Simulate execution (replace with actual API calls)
    try {
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Check if this is a code generation node
      if (currentNode && currentNode.data.type === 'code_generation') {
        // Generate sample code files based on the node configuration
        const sampleFiles = [
          {
            name: 'index.html',
            content: `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated App - ${currentNode.data.config?.app_name || 'My App'}</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>${currentNode.data.config?.app_name || 'Generated Application'}</h1>
            <p>${currentNode.data.config?.description || 'A beautiful app generated by Deepia workflow'}</p>
        </header>
        
        <main>
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>üöÄ Fast Performance</h3>
                    <p>Optimized for speed and efficiency</p>
                </div>
                <div class="feature-card">
                    <h3>üì± Responsive Design</h3>
                    <p>Works perfectly on all devices</p>
                </div>
                <div class="feature-card">
                    <h3>üé® Modern UI</h3>
                    <p>Clean and intuitive interface</p>
                </div>
            </div>
            
            <div class="interaction-section">
                <button id="actionBtn" class="primary-btn">Click Me!</button>
                <div id="output" class="output-area"></div>
            </div>
        </main>
    </div>
    
    <script src="script.js"></script>
</body>
</html>`,
            language: 'html'
          },
          {
            name: 'style.css',
            content: `/* Generated CSS for ${currentNode.data.config?.app_name || 'My App'} */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: #333;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    color: white;
    margin-bottom: 3rem;
}

header h1 {
    font-size: 3rem;
    margin-bottom: 1rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

header p {
    font-size: 1.2rem;
    opacity: 0.9;
}

.feature-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
    margin-bottom: 3rem;
}

.feature-card {
    background: white;
    padding: 2rem;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    transition: transform 0.3s ease;
}

.feature-card:hover {
    transform: translateY(-10px);
}

.feature-card h3 {
    font-size: 1.5rem;
    margin-bottom: 1rem;
    color: #667eea;
}

.interaction-section {
    text-align: center;
    background: white;
    padding: 3rem;
    border-radius: 20px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.1);
}

.primary-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    border: none;
    padding: 1rem 2rem;
    font-size: 1.2rem;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
}

.primary-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 25px rgba(102, 126, 234, 0.6);
}

.output-area {
    margin-top: 2rem;
    padding: 1.5rem;
    background: #f8f9fa;
    border-radius: 10px;
    min-height: 100px;
    border: 2px dashed #dee2e6;
    font-family: 'Courier New', monospace;
}

@media (max-width: 768px) {
    header h1 {
        font-size: 2rem;
    }
    
    .feature-grid {
        grid-template-columns: 1fr;
    }
    
    .interaction-section {
        padding: 2rem;
    }
}`,
            language: 'css'
          },
          {
            name: 'script.js',
            content: `// Generated JavaScript for ${currentNode.data.config?.app_name || 'My App'}
console.log('üöÄ Generated app initialized!');

// App configuration
const appConfig = {
    name: '${currentNode.data.config?.app_name || 'My App'}',
    version: '1.0.0',
    framework: '${currentNode.data.config?.framework || 'Vanilla JS'}',
    features: ${JSON.stringify(currentNode.data.config?.features || ['responsive', 'interactive', 'modern'])}
};

// DOM elements
const actionBtn = document.getElementById('actionBtn');
const output = document.getElementById('output');

// State management
let clickCount = 0;
let appState = {
    initialized: true,
    lastAction: null,
    data: []
};

// Utility functions
function formatDateTime() {
    return new Date().toLocaleString('ja-JP');
}

function generateRandomData() {
    const data = [];
    for (let i = 0; i < 5; i++) {
        data.push({
            id: Math.floor(Math.random() * 1000),
            value: Math.floor(Math.random() * 100),
            timestamp: formatDateTime()
        });
    }
    return data;
}

function updateOutput(content) {
    output.innerHTML = content;
    output.style.opacity = '0';
    setTimeout(() => {
        output.style.transition = 'opacity 0.5s ease';
        output.style.opacity = '1';
    }, 100);
}

// Event handlers
actionBtn.addEventListener('click', function() {
    clickCount++;
    appState.lastAction = 'button_click';
    appState.data = generateRandomData();
    
    const messages = [
        \`üéâ „Éú„Çø„É≥„Åå \${clickCount} Âõû„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü!\`,
        \`‚ö° \${appConfig.name} „ÅåÂãï‰Ωú‰∏≠...\`,
        \`üìä „Éá„Éº„Çø„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü (\${appState.data.length} ‰ª∂)\`,
        \`üïí ÊúÄÁµÇÊõ¥Êñ∞: \${formatDateTime()}\`
    ];
    
    const outputHTML = \`
        <div style="text-align: left;">
            \${messages.map(msg => \`<div style="margin: 0.5rem 0; padding: 0.5rem; background: white; border-radius: 5px; border-left: 4px solid #667eea;">\${msg}</div>\`).join('')}
            
            <details style="margin-top: 1rem;">
                <summary style="cursor: pointer; font-weight: bold; color: #667eea;">ÁîüÊàê„Åï„Çå„Åü„Éá„Éº„Çø„ÇíË°®Á§∫</summary>
                <pre style="background: #2d3748; color: #e2e8f0; padding: 1rem; border-radius: 5px; margin-top: 0.5rem; overflow-x: auto;">\${JSON.stringify(appState.data, null, 2)}</pre>
            </details>
        </div>
    \`;
    
    updateOutput(outputHTML);
    
    // Update button text
    const buttonTexts = ['„Åô„Åî„ÅÑ!', '„ÇÇ„ÅÜ‰∏ÄÂ∫¶!', '„ÅÑ„ÅÑ„Å≠!', 'ÊúÄÈ´ò!', '„ÇØ„É™„ÉÉ„ÇØ!'];
    actionBtn.textContent = buttonTexts[Math.floor(Math.random() * buttonTexts.length)];
    
    console.log('Action performed:', {
        clickCount,
        appState: appState,
        timestamp: formatDateTime()
    });
});

// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    console.log('App configuration:', appConfig);
    updateOutput(\`
        <div style="text-align: center; color: #667eea;">
            <h3>üéØ \${appConfig.name} „Å∏„Çà„ÅÜ„Åì„Åù!</h3>
            <p>„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Ç¢„Éó„É™„Çí‰ΩìÈ®ì„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
            <small>Framework: \${appConfig.framework} | Version: \${appConfig.version}</small>
        </div>
    \`);
});

// Export for potential module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { appConfig, appState };
}`,
            language: 'javascript'
          }
        ];
        
        setGeneratedCode(sampleFiles);
        setShowCodeBrowser(true);
      }
      
      // Update node to show completed state
      setNodes((nds) =>
        nds.map((node) =>
          node.id === nodeId
            ? { ...node, data: { ...node.data, isExecuting: false, hasError: false } }
            : node
        )
      );
    } catch (error) {
      // Update node to show error state
      setNodes((nds) =>
        nds.map((node) =>
          node.id === nodeId
            ? { ...node, data: { ...node.data, isExecuting: false, hasError: true } }
            : node
        )
      );
    } finally {
      setExecutingNodes(prev => {
        const newArray = Array.from(prev).filter(id => id !== nodeId);
        return new Set(newArray);
      });
    }
  }, [setNodes, nodes]);

  const addNode = useCallback((template: NodeTemplate) => {
    const newNodeId = `${template.type}_${Date.now()}`;
    const position = {
      x: Math.random() * 300,
      y: Math.random() * 300,
    };

    const newNode: Node = {
      id: newNodeId,
      type: 'custom',
      position,
      data: {
        id: newNodeId,
        type: template.type,
        label: template.name,
        description: template.description,
        config: { ...template.defaultConfig },
        inputs: template.inputs.map(input => ({ ...input, value: undefined })),
        outputs: template.outputs.map(output => ({ ...output, value: undefined })),
        onDelete: deleteNode,
        onConfigure: configureNode,
        onExecute: executeNode,
        isExecuting: false,
        hasError: false
      } as NodeData & {
        onDelete: (id: string) => void;
        onConfigure: (id: string) => void;
        onExecute: (id: string) => void;
        isExecuting: boolean;
        hasError: boolean;
      }
    };

    setNodes((nds) => [...nds, newNode]);
    setShowNodeSelector(false);
  }, [setNodes, deleteNode, configureNode, executeNode]);

  const executeWorkflow = useCallback(async () => {
    if (!apiClient) {
      console.error('API client not available');
      return;
    }

    setIsExecuting(true);
    
    try {
      const executionService = new WorkflowExecutionService(apiClient);
      
      await executionService.executeWorkflow(
        nodes as WorkflowNode[],
        edges as WorkflowEdge[],
        (nodeId) => {
          // „Éé„Éº„ÉâÂÆüË°åÈñãÂßã
          setNodes((nds) =>
            nds.map((node) =>
              node.id === nodeId
                ? { ...node, data: { ...node.data, isExecuting: true, hasError: false } }
                : node
            )
          );
        },
        (nodeId, result) => {
          // „Éé„Éº„ÉâÂÆüË°åÂÆå‰∫Ü
          setNodes((nds) =>
            nds.map((node) =>
              node.id === nodeId
                ? { ...node, data: { ...node.data, isExecuting: false, hasError: false } }
                : node
            )
          );
          console.log(`Node ${nodeId} completed:`, result);
        },
        (nodeId, error) => {
          // „Éé„Éº„ÉâÂÆüË°å„Ç®„É©„Éº
          setNodes((nds) =>
            nds.map((node) =>
              node.id === nodeId
                ? { ...node, data: { ...node.data, isExecuting: false, hasError: true } }
                : node
            )
          );
          console.error(`Node ${nodeId} failed:`, error);
        }
      );
      
      console.log('Workflow execution completed');
      
    } catch (error) {
      console.error('Workflow execution failed:', error);
    } finally {
      setIsExecuting(false);
    }
  }, [nodes, edges, apiClient, setNodes]);

  const saveWorkflow = useCallback(async () => {
    // Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ
    if (!user) {
      if (onAuthRequired) {
        onAuthRequired();
      }
      return;
    }

    if (!apiClient) {
      console.error('API client not available');
      return;
    }

    const workflow = {
      id: `workflow_${Date.now()}`,
      name: `„ÉØ„Éº„ÇØ„Éï„É≠„Éº ${new Date().toLocaleString()}`,
      description: `${nodes.length}ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂê´„ÇÄ„ÉØ„Éº„ÇØ„Éï„É≠„Éº`,
      nodes: nodes as WorkflowNode[],
      edges: edges as WorkflowEdge[],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      // Save to API
      const response = await apiClient.post('/api/content/workflow/save/', workflow);
      
      if (response.status === 201) {
        console.log('Workflow saved to API:', response.data);
        
        // Also save to localStorage as backup
        const savedWorkflows = JSON.parse(localStorage.getItem('workflows') || '[]');
        savedWorkflows.push(workflow);
        localStorage.setItem('workflows', JSON.stringify(savedWorkflows));
        
        alert('„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„ÅüÔºÅ');
      }
    } catch (error) {
      console.error('Failed to save workflow to API:', error);
      
      // Fallback to localStorage
      const savedWorkflows = JSON.parse(localStorage.getItem('workflows') || '[]');
      savedWorkflows.push(workflow);
      localStorage.setItem('workflows', JSON.stringify(savedWorkflows));
      
      console.log('Workflow saved to localStorage:', workflow);
      alert('„ÉØ„Éº„ÇØ„Éï„É≠„Éº„Åå„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü');
    }
  }, [nodes, edges, apiClient, user, onAuthRequired]);

  const loadTemplate = useCallback((templateId: string) => {
    const template = workflowTemplates.find(t => t.id === templateId);
    if (!template) return;

    // Convert template nodes to React Flow nodes
    const templateNodes = template.nodes.map(node => ({
      ...node,
      data: {
        ...node.data,
        onDelete: deleteNode,
        onConfigure: configureNode,
        onExecute: executeNode,
        isExecuting: false,
        hasError: false
      }
    }));

    setNodes(templateNodes);
    setEdges(template.edges);
    setShowTemplateSelector(false);
    
    console.log('Template loaded:', template.name);
  }, [deleteNode, configureNode, executeNode, setNodes, setEdges]);

  const selectedNode = useMemo(() => {
    return selectedNodeForConfig ? nodes.find(node => node.id === selectedNodeForConfig) : null;
  }, [selectedNodeForConfig, nodes]);

  const updateNodeConfig = useCallback((nodeId: string, config: any) => {
    setNodeConfigs(prev => ({ ...prev, [nodeId]: config }));
    setNodes((nds) =>
      nds.map((node) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, config } }
          : node
      )
    );
  }, [setNodes]);

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth={false}
      fullWidth
      PaperProps={{
        sx: {
          width: '95vw',
          height: '90vh',
          backgroundColor: 'rgba(0, 0, 0, 0.95)',
          color: 'white'
        }
      }}
    >
      <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h5" fontWeight="bold">
          ü§ñ Agentic Workflow Editor
        </Typography>
        <Box display="flex" gap={1}>
          <Button
            variant="contained"
            startIcon={<TemplateIcon />}
            onClick={() => setShowTemplateSelector(true)}
            sx={{ backgroundColor: '#9c27b0' }}
          >
            „ÉÜ„É≥„Éó„É¨„Éº„Éà
          </Button>
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={() => setShowNodeSelector(true)}
            sx={{ backgroundColor: '#667eea' }}
          >
            „Éé„Éº„ÉâËøΩÂä†
          </Button>
          <Button
            variant="contained"
            startIcon={<PlayIcon />}
            onClick={executeWorkflow}
            disabled={isExecuting || nodes.length === 0}
            sx={{ backgroundColor: '#4caf50' }}
          >
            ÂÆüË°å
          </Button>
          <Button
            variant="outlined"
            startIcon={<SaveIcon />}
            onClick={saveWorkflow}
            sx={{ borderColor: 'white', color: 'white' }}
          >
            ‰øùÂ≠ò
          </Button>
          <IconButton onClick={onClose} sx={{ color: 'white' }}>
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>

      <DialogContent sx={{ height: '100%', p: 0 }}>
        <ReactFlowProvider>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            nodeTypes={nodeTypes}
            connectionMode={ConnectionMode.Loose}
            style={{
              backgroundColor: '#0a0a0a',
            }}
          >
            <Background color="#333" gap={20} />
            <Controls />
            <MiniMap
              style={{
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                border: '1px solid #333'
              }}
              nodeColor="#667eea"
              maskColor="rgba(0, 0, 0, 0.5)"
            />
            
            <Panel position="top-left">
              <Box sx={{ backgroundColor: 'rgba(0, 0, 0, 0.8)', p: 2, borderRadius: 2 }}>
                <Typography variant="h6" color="white" mb={1}>
                  „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÁµ±Ë®à
                </Typography>
                <Typography variant="body2" color="rgba(255, 255, 255, 0.8)">
                  „Éé„Éº„Éâ: {nodes.length} | „Ç®„ÉÉ„Ç∏: {edges.length}
                </Typography>
                {isExecuting && (
                  <Chip
                    label="ÂÆüË°å‰∏≠..."
                    size="small"
                    sx={{ mt: 1, backgroundColor: '#ff9800', color: 'white' }}
                  />
                )}
              </Box>
            </Panel>
          </ReactFlow>
        </ReactFlowProvider>
      </DialogContent>

      {/* Node Selector Dialog */}
      <Dialog
        open={showNodeSelector}
        onClose={() => setShowNodeSelector(false)}
        maxWidth="sm"
        fullWidth
        PaperProps={{
          sx: {
            backgroundColor: 'rgba(0, 0, 0, 0.95)',
            color: 'white'
          }
        }}
      >
        <DialogTitle>„Éé„Éº„Éâ„ÇíÈÅ∏Êäû</DialogTitle>
        <DialogContent>
          {nodeCategories.map((category) => (
            <Accordion key={category.id} sx={{ backgroundColor: 'rgba(255, 255, 255, 0.05)' }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon sx={{ color: 'white' }} />}>
                <Typography color="white">
                  {category.icon} {category.name}
                </Typography>
              </AccordionSummary>
              <AccordionDetails>
                <List>
                  {nodeTemplates
                    .filter((template) => template.category === category.id)
                    .map((template) => (
                      <ListItem
                        key={template.id}
                        button
                        onClick={() => addNode(template)}
                        sx={{
                          borderRadius: 2,
                          mb: 1,
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          '&:hover': {
                            backgroundColor: 'rgba(255, 255, 255, 0.1)',
                          },
                        }}
                      >
                        <ListItemIcon>
                          <Typography variant="h6">{template.icon}</Typography>
                        </ListItemIcon>
                        <ListItemText
                          primary={template.name}
                          secondary={template.description}
                          sx={{
                            '& .MuiListItemText-primary': { color: 'white' },
                            '& .MuiListItemText-secondary': { color: 'rgba(255, 255, 255, 0.7)' },
                          }}
                        />
                        <Chip
                          label={template.type}
                          size="small"
                          sx={{
                            backgroundColor: template.color,
                            color: 'white',
                          }}
                        />
                      </ListItem>
                    ))}
                </List>
              </AccordionDetails>
            </Accordion>
          ))}
        </DialogContent>
      </Dialog>

      {/* Template Selector Dialog */}
      <Dialog
        open={showTemplateSelector}
        onClose={() => setShowTemplateSelector(false)}
        maxWidth="md"
        fullWidth
        PaperProps={{
          sx: {
            backgroundColor: 'rgba(0, 0, 0, 0.95)',
            color: 'white'
          }
        }}
      >
        <DialogTitle>„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÈÅ∏Êäû</DialogTitle>
        <DialogContent>
          <Typography variant="body2" color="rgba(255, 255, 255, 0.7)" mb={3}>
            ‰∫ãÂâç„Å´Ë®≠ÂÆö„Åï„Çå„Åü„ÉØ„Éº„ÇØ„Éï„É≠„Éº„ÉÜ„É≥„Éó„É¨„Éº„Éà„Åã„ÇâÈÅ∏Êäû„Åó„Å¶„ÄÅ„Åô„Åê„Å´‰Ωø„ÅÑÂßã„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
          </Typography>
          <List>
            {workflowTemplates.map((template) => (
              <ListItem
                key={template.id}
                button
                onClick={() => loadTemplate(template.id)}
                sx={{
                  borderRadius: 2,
                  mb: 2,
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  backgroundColor: 'rgba(255, 255, 255, 0.02)',
                  '&:hover': {
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                  },
                }}
              >
                <ListItemIcon>
                  <Typography variant="h5">
                    {template.id.includes('content') ? 'üé®' : 
                     template.id.includes('code') ? 'üíª' : 
                     template.id.includes('3d') ? 'üßä' : '‚öôÔ∏è'}
                  </Typography>
                </ListItemIcon>
                <ListItemText
                  primary={template.name}
                  secondary={
                    <Box>
                      <Typography variant="body2" color="rgba(255, 255, 255, 0.7)" mb={1}>
                        {template.description}
                      </Typography>
                      <Box display="flex" gap={1}>
                        <Chip
                          label={`${template.nodes.length} „Éé„Éº„Éâ`}
                          size="small"
                          sx={{
                            backgroundColor: 'rgba(102, 126, 234, 0.3)',
                            color: 'white',
                            fontSize: '0.75rem'
                          }}
                        />
                        <Chip
                          label={`${template.edges.length} Êé•Á∂ö`}
                          size="small"
                          sx={{
                            backgroundColor: 'rgba(156, 39, 176, 0.3)',
                            color: 'white',
                            fontSize: '0.75rem'
                          }}
                        />
                      </Box>
                    </Box>
                  }
                  sx={{
                    '& .MuiListItemText-primary': { 
                      color: 'white',
                      fontWeight: 'bold',
                      fontSize: '1.1rem'
                    },
                  }}
                />
              </ListItem>
            ))}
          </List>
        </DialogContent>
      </Dialog>

      {/* Node Configuration Drawer */}
      <Drawer
        anchor="right"
        open={!!selectedNodeForConfig}
        onClose={() => setSelectedNodeForConfig(null)}
        PaperProps={{
          sx: {
            width: 400,
            backgroundColor: 'rgba(0, 0, 0, 0.95)',
            color: 'white'
          }
        }}
      >
        {selectedNode && (
          <Box sx={{ p: 3 }}>
            <Typography variant="h6" mb={2}>
              {selectedNode.data.label} Ë®≠ÂÆö
            </Typography>

            <Divider sx={{ mb: 2, borderColor: 'rgba(255, 255, 255, 0.2)' }} />

            {/* Basic node info */}
            <Box mb={3}>
              <TextField
                fullWidth
                label="„Éé„Éº„ÉâÂêç"
                value={selectedNode.data.label}
                onChange={(e) => {
                  setNodes((nds) =>
                    nds.map((node) =>
                      node.id === selectedNode.id
                        ? { ...node, data: { ...node.data, label: e.target.value } }
                        : node
                    )
                  );
                }}
                sx={{ mb: 2 }}
                InputProps={{
                  style: { color: 'white' }
                }}
                InputLabelProps={{
                  style: { color: 'rgba(255, 255, 255, 0.7)' }
                }}
              />
            </Box>

            {/* Dynamic Configuration fields based on node template */}
            <Box>
              {selectedNode.data.inputs?.map((input: any) => (
                <Box key={input.id} sx={{ mb: 2 }}>
                  {input.type === 'select' && input.options ? (
                    <FormControl fullWidth>
                      <InputLabel sx={{ color: 'rgba(255, 255, 255, 0.7)' }}>
                        {input.name}
                      </InputLabel>
                      <Select
                        value={selectedNode.data.config?.[input.id] || selectedNode.data.config?.[input.name] || ''}
                        onChange={(e) =>
                          updateNodeConfig(selectedNode.id, {
                            ...selectedNode.data.config,
                            [input.id]: e.target.value
                          })
                        }
                        sx={{ color: 'white' }}
                      >
                        {input.options.map((option: any) => (
                          <MenuItem key={option} value={option}>
                            {option}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  ) : input.type === 'number' ? (
                    <TextField
                      fullWidth
                      label={input.name}
                      type="number"
                      value={selectedNode.data.config?.[input.id] || selectedNode.data.config?.[input.name] || ''}
                      onChange={(e) =>
                        updateNodeConfig(selectedNode.id, {
                          ...selectedNode.data.config,
                          [input.id]: parseFloat(e.target.value) || parseInt(e.target.value)
                        })
                      }
                      InputProps={{ style: { color: 'white' } }}
                      InputLabelProps={{ style: { color: 'rgba(255, 255, 255, 0.7)' } }}
                    />
                  ) : input.type === 'text' ? (
                    <TextField
                      fullWidth
                      label={input.name}
                      multiline={input.id.includes('prompt') || input.id.includes('text')}
                      rows={input.id.includes('prompt') || input.id.includes('text') ? 3 : 1}
                      value={selectedNode.data.config?.[input.id] || selectedNode.data.config?.[input.name] || ''}
                      onChange={(e) =>
                        updateNodeConfig(selectedNode.id, {
                          ...selectedNode.data.config,
                          [input.id]: e.target.value
                        })
                      }
                      InputProps={{ style: { color: 'white' } }}
                      InputLabelProps={{ style: { color: 'rgba(255, 255, 255, 0.7)' } }}
                    />
                  ) : (
                    <TextField
                      fullWidth
                      label={input.name}
                      value={selectedNode.data.config?.[input.id] || selectedNode.data.config?.[input.name] || ''}
                      onChange={(e) =>
                        updateNodeConfig(selectedNode.id, {
                          ...selectedNode.data.config,
                          [input.id]: e.target.value
                        })
                      }
                      InputProps={{ style: { color: 'white' } }}
                      InputLabelProps={{ style: { color: 'rgba(255, 255, 255, 0.7)' } }}
                    />
                  )}
                </Box>
              ))}
              
              {/* Additional configuration fields from defaultConfig */}
              {selectedNode.data.type && Object.keys(selectedNode.data.config || {}).map((configKey) => {
                // Skip if already covered in inputs
                const alreadyCovered = selectedNode.data.inputs?.some((input: any) => 
                  input.id === configKey || input.name === configKey
                );
                if (alreadyCovered) return null;
                
                return (
                  <TextField
                    key={configKey}
                    fullWidth
                    label={configKey.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase())}
                    value={selectedNode.data.config?.[configKey] || ''}
                    onChange={(e) =>
                      updateNodeConfig(selectedNode.id, {
                        ...selectedNode.data.config,
                        [configKey]: e.target.value
                      })
                    }
                    sx={{ mb: 2 }}
                    InputProps={{ style: { color: 'white' } }}
                    InputLabelProps={{ style: { color: 'rgba(255, 255, 255, 0.7)' } }}
                  />
                );
              })}
            </Box>

            <Button
              variant="contained"
              fullWidth
              onClick={() => setSelectedNodeForConfig(null)}
              sx={{ mt: 3, backgroundColor: '#667eea' }}
            >
              Ë®≠ÂÆöÂÆå‰∫Ü
            </Button>
          </Box>
        )}
      </Drawer>

      {/* Code Browser Dialog */}
      <Dialog
        open={showCodeBrowser}
        onClose={() => setShowCodeBrowser(false)}
        maxWidth={false}
        fullWidth
        PaperProps={{
          sx: {
            width: '95vw',
            height: '90vh',
            backgroundColor: 'white'
          }
        }}
      >
        <CodeBrowser
          initialFiles={generatedCode}
          title="Generated Code Browser"
          user={user}
          onAuthRequired={onAuthRequired}
          onSave={(files) => {
            console.log('Saving generated code:', files);
            // Here you could save the code to the API or local storage
            alert('„Ç≥„Éº„Éâ„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„ÅüÔºÅ');
          }}
          onShare={(files) => {
            console.log('Sharing generated code:', files);
            // Here you could implement sharing functionality
            alert('„Ç≥„Éº„Éâ„ÅåÂÖ±Êúâ„Åï„Çå„Åæ„Åó„ÅüÔºÅ');
          }}
        />
        <Box sx={{ position: 'absolute', top: 8, right: 8 }}>
          <IconButton 
            onClick={() => setShowCodeBrowser(false)}
            sx={{ backgroundColor: 'rgba(0,0,0,0.1)', '&:hover': { backgroundColor: 'rgba(0,0,0,0.2)' } }}
          >
            <CloseIcon />
          </IconButton>
        </Box>
      </Dialog>
    </Dialog>
  );
};